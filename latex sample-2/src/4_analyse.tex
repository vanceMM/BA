\section{Analyse und Aufgabenstellung}\label{analysis}

%Open Badges können über das criteria und alignment field mit Kompetenzen aus externen Kompetenzframeworks verlinkt werden. Daraus ergibt sich die Anforderung Badges mit ähnlichen Kompetezen, Badges die sich ergänzen oder identisch sind zu ermitteln, aber auch fehlende Kompetenzen zu identifizieren die benötigt werden um einen gewünschten Badge zu erlangen. \cite{OBNO3-A2}
%
%
%Problematisch sind die verschiedenen Standards der einzelnen Kompetenzframeworks. So gibt es nicht nur nationale und sprachliche Unterschiede sondern auch Unterschiede in den veröffentlichen Formaten. Von den bisher veröffentlichten Kompetenzframeworks bietet momentan nur ESCO den Download der Daten in einem maschinenlesbaren Format(CSV, XML, RDF) an. 

Eine der großen Herausforderung in der Personalentwicklung ist das Job-Matching, eine vakante Stelle mit einem passenden Bewerber oder Angestellten zu besetzen. Dabei greifen Personaler vermehrt auf Technologien und Matching-Algorithmen zurück die diesen Prozess automatisieren sollen. Das Prinzip ähnelt dem, der Partnervermittlung. Person A, Der Arbeitgeber wird mit Person B, dem Arbeitssuchenden oder Angestellten zusammen gebracht. Unter Berücksichtigung von Kompetenzen die eine Stelle erfordert, kann dieses Matching Verfahren verfeinert werden.


\vspace{1em}

\subsection{Aufgabenstellung}

Ein wichtiger Bestandteil von Stellenbeschreibungen sind auch eine Liste von geforderten Kompetenzen. Kompetenzen lassen sich als Graph modellieren, denn oftmals bestehen zwischen ihnen hierarchische Strukturen und Gemeinsamkeiten. Das Ziel dieser Arbeit soll es sein, Die Beziehungen dieser Kompetenzen in einem Graphenmodell zu analysieren, und Methoden und Metriken zu finden mit deren Hilfe es möglich sein wird, Ähnlichkeiten von einzelnen Kompetenzen oder ganzen Kompetenzsets zu ermitteln. Konkret soll ein Dienst entwickelt werden, der von anderen Programmen genutzt, oder in bestehende Systeme integriert werden kann.

\subsection{Anforderungsanalyse} 

\subsubsection{Kompetenzen}

Kompetenzen sind die Entitäten welche von dem Empfehlungsystem verarbeitet werden sollen. Sie können ihren Ursprung außerhalb des Systems haben, werden aber innerhalb in einer Datenschicht persistiert. Ursprung von Kompetenzen können ein \textit{Kompetenzrepository} wie es Herr Lopez in seiner Arbeit \textit{Entwicklung und Evaluation eines e-Kompetenz-Verzeichnisses mit REST-API und eines automatisierten Crawlers zur Datensammlung}\cite{lopez} entwickelt hat, oder ein Katalog mit Kompetenzen wie \textit{ESCO} von der Europäischen Kommission. Auch Kompetenzen aus Kompetenzrahmen wären als Quelle denkbar, sofern diese in einem maschinenlesbaren Format zur Verfügung stehen. 

\subsubsection{Anforderungen an die Engine}
Ein solches Empfehlungssystem soll als eigener Dienst fungieren, und über eine API erreichbar sein. Die Eingabe für das Empfehlungssystem soll eine Kompetenz oder eine ein Set von Kompetenzen sein. Kompetenzen werden in einer Datenschicht persistiert, die die gängigen CRUD Datenbankoperationen ermöglicht. Die API leitet die Kompetenzen dann an eine Methode weiter, welche die nötigen Entitäten und deren Beziehungen zurück liefert. Auf resultierenden Datensätzen können weitere Operationen, wie Aggregation oder Sortierung durchgeführt werden und falls weitere Berechnungen oder Operationen nötig sind die mit der Abfragensprache nicht geleistet werden, mit einer einer gängigen Programmiersprache weitere algorithmische Schritte implementieren. Am Ende sollen 0, 1 oder mehrere Kompetenzen in sortierter Reihenfolge an den Aufrufer zurückgeliefert werden.

Folgende Anforderungen können an dieses System gestellt werden.
\begin{itemize}
	\item Übereinstimmung von Kompetenzsets ermitteln
	\item Ähnlichkeit von Kompetenzsets ermitteln
	\item Ähnliche Kompetenzen finden
	\item Inkludierende Kompetenzen ermitteln
	\item Fehlende Kompetenzen ermitteln
\end{itemize}

Optionale Anforderungen

\begin{itemize}
	\item Vergleich von Kompetenzen aus verschiedenen Frameworks
\end{itemize}

\subsubsection{Anforderungen an die API}

Das Empfehlungssystem soll über eine API für andere Softwaresysteme verfügbar sein. Beispiele für solche Systeme können Jobportale oder Human Resource Management Systeme sein. Sie können über HTTP Requests Daten mit Kompetenzsets an die Engine senden und erhalten verarbeitete Daten als Antwort.

Mit der Übereinstimmung von Kompetenzsets zb. das einer Stellenbeschreibung und das eines Lebenslaufes, kann ein Matching vorgenommen werden, welches Computersystemen ermöglicht passende Stellenangebote oder Bewerber zu finden. Über die Vernetzung der Kompetenzen im Graphen können Wege zur weiteren Bildung ermittelt werden.


\subsubsection{Anforderungen an die Architektur}

Der Dienst soll als nach dem Microservice Muster implementiert werden, also bei Bedarf komplett austauschbar sein und wenige Abhängigkeiten enthalten. Nutzer sollen über das HTTP Protokoll mit dem Dienst kommunizieren können. Die Daten werden in einem Graphen persistiert, in welchem Kompetenzen als Knoten und Beziehungen der Kompetenzen als Kanten gespeichert werden. Für die Kommunikation soll ein gängiges Format zur Ein und Ausgabe gewählt werden.

\begin{itemize}
	\item Erreichbarkeit über eine Web-API 
	\item Persistenz der Daten in einem Graphen	
	\item Daten Ein und Ausgabe in einem standardisierten Format 
	\item Skalierbarkeit: soll viele Anfragen gleichzeitig bearbeiten können
\end{itemize}


\subsection{Algorithmen und Metriken}

Das Kernproblem des Empfehlungsdienstes ist die Berechnung von Ähnlichkeiten von Knoten in einem Graphen. Es gibt bereits einige Algorithmen die sich mit dieser Problematik auseinander setzen. Ein grundsätzlicher Ansatz kann lautet,\textit{ je näher zwei Knoten im Graphen einander sind, desto ähnlicher sind sie sich}. Der folgende Graph soll dies veranschaulichen. 

Der Dijkstra-Algorithmus löst das Problem der kürzesten Pfade.

Es gibt aber auch mehr Eigenschaften des Graphen die sich ein Algorithmus zu nutzen machen kann. So können mit Hilfe von gewichteten Kanten Vektoren entlang der Pfade von einem Knoten zu einem anderen erstellt werden. Die \textit{Kosinus-Ähnlichkeit} ist eine Metrik die den eingeschlossenen Winkel zwischen zwei solcher Vektoren ermittelt.


Mit dem Jaccard Koeffizenten lassen sich zwei Mengen auf ihre Ähnlichkeit prüfen. Der Wert des Koeffizienten ist  genau dann 1, wenn die beiden Mengen identisch sind. Je weniger Gemeinsame Elemente zwei Mengen besitzen, desto kleiner wird der  Koeffizient und wird 0, wenn keine Gemeinsamkeiten vorliegen.
\begin{center}
	$ J(A,B)=\frac{\mid A\bigcap B\mid }{ \mid A \bigcup B \mid }$

\end{center}
In einem Graphen kann die Metrik für 2 Knoten angewandt werden, indem man die beiden Mengen aus Knoten zusammen setzt, die eine Beziehung zu den 2 Knoten haben. Kategorien oder Taxonomien sind dabei geeignete Kandidaten für gemeinsame Beziehungen. Am Beispiel des Movie Graphen, kann hier eine Ähnlichkeit von 2 Filmen berechnet werden, die sich in gemeinsamen Genres befinden. 

Ein weiterer Ansatz lautet \textit{"Zwei Objekte sind Ähnlich, wenn sie mit ähnlichen Objekten verknüpft sind"}. Der \textit{SimRank} Algorithmus versucht Ähnlichkeiten von Knoten zu finden zwischen denen ein struktureller Zusammenhang besteht. 


